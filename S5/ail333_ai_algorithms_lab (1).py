# -*- coding: utf-8 -*-
"""AIL333-AI Algorithms Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zVceVADhdKiZge3zfFLCtVpLpHLkrAFW

# **AI Programs**

**Reading Graph** As an Input from User (For DFS,DLS,BFS,M-coloring)

Substitute it in graph ={} part
"""

graph = {}
nodes = input("Enter the nodes (Space Seperated)").split()
for i in range(len(nodes)):
  neigbhour = input(f"Enter the neigbhours of {nodes[i]} (Space Seperated)").split()
  graph[nodes[i]] = neigbhour
print(graph)

"""**Depth First Search**


Algorithm


```
Step 1: Represent the graph using an adjacency list or dictionary structure.
        Represent the start and goal in variables.

Step 2: Define a recursive function dfs(node, goal, graph, visited).

Step 3: Print the current node to show the traversal path.

Step 4: Check if the current node is equal to the goal node.
        If yes, print "\nGoal {goal} found in the graph." and return True.

Step 5: Mark the current node as visited.

Step 6: For each neighbor in graph[node]:
          If the neighbor is not visited:
             Call dfs(neighbor, goal, graph, visited) recursively.
             If the recursive call returns True,
                propagate True upward to stop further searching.

Step 7: If no neighbor leads to the goal, return False.

Step 8: Define a main section to accept user input for start and goal.
        Print "Traversal Path: "
        Call dfs(start, goal, graph, visited=set()).

Step 9: If dfs returns False, print "\nGoal {goal} not found in the graph."

Step 10: End the program.
```


"""

def dfs(node, goal, graph, visited):
    # Print the current node to show traversal
    print(node, end=' ')

    # Check if goal is found
    if node == goal:
        print(f"\nGoal {goal} found in the graph.")
        return True

    # Mark current node as visited
    visited.add(node)

    # Explore neighbors recursively
    for neighbor in graph[node]:
        if neighbor not in visited:
            if dfs(neighbor, goal, graph, visited):
                return True

    # Goal not found down this path
    return False


# --- Driver Code ---
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': ['G'],
    'E': [],
    'F': [],
    'G': []
}

print("Graph:", graph)
start = input("Enter the starting node: ")
goal = input("Enter the goal node: ")

print("Traversal Path: ", end='')
if not dfs(start, goal, graph, set()):
    print(f"\nGoal {goal} not found in the graph.")

"""**Breadth First Search**



```
Step 1: Represent the graph using an adjacency list or dictionary structure.
        Represent the start and goal in variables.

Step 2: Define a function bfs(start, goal, graph).

Step 3: Create a queue (e.g., collections.deque) and a visited set.

Step 4: Enqueue the start node and add it to the visited set.

Step 5: Start a loop that continues while the queue is not empty.

  Step 6: Dequeue a node.

  Step 7: Print the dequeued node to show the traversal path.

  Step 8: Check if the current node is equal to the goal node.
          If yes, print "\nGoal {goal} found in the graph." and return True.

  Step 9: For each neighbor in graph[node]:
            If the neighbor is not visited:
              Add the neighbor to the visited set.
              Enqueue the neighbor.

Step 10: If the loop finishes (queue is empty), return False.

Step 11: Define a main section to accept user input for start and goal.
         Print "Traversal Path: "
         Call bfs(start, goal, graph).

Step 12: If bfs returns False, print "\nGoal {goal} not found in the graph."

Step 13: End the program.
```





"""

from collections import deque

def bfs(start, goal, graph):
    visited = set()
    queue = deque()

    # Add start node to queue and visited set
    queue.append(start)
    visited.add(start)

    while queue:
        # Dequeue a node and print it
        node = queue.popleft()
        print(node, end=' ')

        # Check if goal is found
        if node == goal:
            print(f"\nGoal {goal} found in the graph.")
            return True

        # Explore neighbors
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    # Goal not found after exploring all reachable nodes
    return False


# --- Driver Code ---
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': ['G'],
    'E': [],
    'F': [],
    'G': []
}

print("Graph:", graph)
start = input("Enter the starting node: ")
goal = input("Enter the goal node: ")

print("Traversal Path: ", end='')
if not bfs(start, goal, graph):
    print(f"\nGoal {goal} not found in the graph.")

"""**Depth Limited Search**


Algorithm
```
Step 1: Represent the graph using an adjacency list or dictionary structure.
        Represent the start, goal, and depth limit in variables.

Step 2: Define a recursive function dls(node, goal, graph, limit, visited).

Step 3: Check if the current depth limit has been exceeded (limit < 0).
        If yes, return False (stop further exploration).

Step 4: Mark the current node as visited.

Step 5: Print the current node to show the traversal path.

Step 6: Check if the current node is equal to the goal node.
        If yes, print "\nGoal {goal} found in the graph." and return True.

Step 7: For each neighbor in graph[node]:
          If the neighbor is not visited:
             Call dls(neighbor, goal, graph, limit - 1, visited) recursively.
             If the recursive call returns True,
                propagate True upward to stop further searching.

Step 8: If no neighbor leads to the goal (within the limit), return False.

Step 9: Define a main section to accept user input for start, goal, and limit.
        Print "Traversal Path: "
        Call dls(start, goal, graph, limit, visited=set()).

Step 10: If dls returns False, print "\nGoal {goal} not found within the given depth limit."

Step 11: End the program.

```

*Changes from Depth First Search*


```
# Function has a new parameter 'limit'
def dls(node, goal, graph, limit, visited):

# Added in the Search Function for stopping the search when Limit is reached
# This line is the new first step.
    if limit < 0:
        return False
    
    # ... (rest of the function: print, goal check, visited.add) ...

# On each recursive call, reduce the limit by one
    dls(neighbor, goal, graph, limit - 1, visited)

# Added 'limit' as a user input
limit = int(input("Enter the depth limit: "))

# Pass 'limit' in the main argument list
if not dls(start, goal, graph, limit, set()):
    # ... (updated failure message) ...
```


"""

def dls(node, goal, graph, limit, visited):
    # Stop exploring if depth limit is reached
    if limit < 0:
        return False

    # Mark current node as visited and print it
    visited.add(node)
    print(node, end=' ')

    # Check if goal is found
    if node == goal:
        print(f"\nGoal {goal} found in the graph.")
        return True

    # Explore neighbors recursively (depth-limited)
    for neighbor in graph[node]:
        if neighbor not in visited:
            if dls(neighbor, goal, graph, limit - 1, visited):
                return True

    # Goal not found within this path or limit
    return False


# --- Driver Code ---
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': ['G'],
    'E': [],
    'F': [],
    'G': []
}

print("Graph:", graph)
start = input("Enter the starting node: ")
goal = input("Enter the goal node: ")
limit = int(input("Enter the depth limit: "))

print("Traversal Path: ", end='')
if not dls(start, goal, graph, limit, set()):
    print(f"\nGoal {goal} not found within the given depth limit.")

"""**Uniform Cost Search**
*Without Input Handling*


```
1. Represent the graph using an adjacency list or dictionary structure.
        Represent the start, goal in variables.
2. Maintain a priority queue (called pq) to decide which node to visit next.
3. Store items in the pq as a tuple: (cost_so_far, node, current_path_list).
4. Add the start node to pq with a cost of 0 and a path list [start].
5. Create a visited set to avoid expanding the same node multiple times.
6. Loop as long as the pq is not empty:
   6.1. Pop the item with the lowest cost from pq. This gives the current g (cost), node, and path.
   6.2. If the node is the goal:
        6.2.1. Print the path and the g (cost).
        6.2.2. Return (the search is complete).
   6.3. If the node has not been visited yet:
        6.3.1. Add the node to the visited set.
        6.3.2. For each neighbor (and its cost) of the current node:
               6.3.2.1. Calculate the new cost to reach that neighbor: new_g = g + cost.
               6.3.2.2. Create the new path by appending the neighbor: new_path = path + [neighbor].
               6.3.2.3. Push the new tuple (new_g, neighbor, new_path) onto the pq.
7. Stop.
```


"""

import heapq

# --- Input Data ---
graph = {
    'A': [('B', 1), ('C', 3)],
    'B': [('D', 3), ('E', 1)],
    'C': [('F', 5)],
    'D': [],
    'E': [('F', 2)],
    'F': []
}

# --- UCS Function ---
def ucs(start, goal):
    # pq stores: (g_score, node, path_list)
    pq = [(0, start, [start])]
    visited = set()

    while pq:
        # Get the item with the lowest g_score
        g, node, path = heapq.heappop(pq)

        # If this is the goal, we are done
        if node == goal:
            print("Path:", path, "Cost:", g)
            return

        # If we haven't visited this node, expand it
        if node not in visited:
            visited.add(node)

            # Add all neighbors to the priority queue
            for neighbor, cost in graph[node]:
                new_g = g + cost
                # We create a new path list for each neighbor
                heapq.heappush(pq, (new_g, neighbor, path + [neighbor]))

# --- Run the program ---
ucs('A', 'F')

"""**UCS** With Input Handling (Recomended)


```
1. Start.
2. Build a graph (adjacency list) from the list of edges.
3. Create an empty 'visited' set.
4. Create an empty priority queue (priority_queue).
5. Push the initial item onto the priority_queue: (0, start_node, [start_node]). This tuple represents (total_cost, node, path).
6. Loop as long as the priority_queue is not empty:
   6.1. Pop the item with the lowest total_cost from priority_queue. This gives current_cost, current_node, and current_path.
   6.2. If current_node is already in the 'visited' set, continue (skip this iteration).
   6.3. Add current_node to the 'visited' set.
   6.4. If current_node is the goal_node:
        6.4.1. Print the final current_path and current_cost.
        6.4.2. Return (the search is complete).
   6.5. For each neighbor (and its step_cost) of the current_node:
        6.5.1. If neighbor is not in the 'visited' set:
             6.5.1.1. Calculate the new cost to reach that neighbor: new_cost = current_cost + step_cost.
             6.5.1.2. Create the new path by appending the neighbor: new_path = current_path + [neighbor].
             6.5.1.3. Push the new tuple (new_cost, neighbor, new_path) onto the priority_queue.
7. If the loop finishes (queue is empty) and the goal was not found, print "No path exists".
8. Stop.
```


"""

import heapq

def UCS(edges, start_node, goal_node):
    # Build a graph (adjacency list) from the list of edges.
    graph = {}
    for from_node, to_node, cost in edges:
        # Ensure the 'from' node is a key in the graph
        if from_node not in graph:
            graph[from_node] = []
        # Ensure the 'to' node is a key (for nodes that might only be destinations)
        if to_node not in graph:
            graph[to_node] = []

        # Add the directed edge with its cost
        graph[from_node].append((to_node, cost))

    # Create an empty 'visited' set to track explored nodes.
    visited = set()

    # Create an empty priority queue (min-heap).
    # We will store tuples: (total_cost, node, path_list)
    priority_queue = []

    # Push the initial item onto the priority queue.
    # The cost to reach the start_node from itself is 0.
    heapq.heappush(priority_queue, (0, start_node, [start_node]))

    # Loop as long as the priority_queue is not empty
    while priority_queue:

        # Pop the item with the lowest total_cost (this is the core of UCS)
        current_cost, current_node, current_path = heapq.heappop(priority_queue)

        # If we've already found a cheaper path to this node, skip it
        if current_node in visited:
            continue

        # Mark the current node as visited
        visited.add(current_node)

        # Goal check: If this is the node we're looking for, we're done.
        if current_node == goal_node:
            print(f"Path found, The final Cost: {current_cost}")
            print(" ".join(map(str, current_path)))
            return # Exit the function

        # Iterate over all neighbors of the current node
        for neighbor, step_cost in graph[current_node]:

            # Only process neighbors that haven't been visited yet
            if neighbor not in visited:

                # Calculate the new total cost to reach this neighbor
                new_cost = current_cost + step_cost

                # Create the new path by appending the neighbor
                new_path = current_path + [neighbor]

                # Push the new state (cost, node, path) onto the priority queue
                heapq.heappush(priority_queue, (new_cost, neighbor, new_path))

    # If the loop finishes without returning, the goal was never reached
    print("No path exists")

# --- Input handling ---
num_edges = int(input('Enter the number of edges: '))
edges = []
print("Enter From To Cost for each edge (Space Separated): ")
for _ in range(num_edges):
    from_node, to_node, cost_str = input().split()
    cost = int(cost_str)
    edges.append((from_node, to_node, cost))  # Store edges as (from, to, cost)

start_node = input("Enter the starting node: ")
goal_node = input("Enter the goal node: ")

# Call the UCS function
UCS(edges, start_node, goal_node)

"""A* Search *Without Input Handling*


```
1. Represent the graph using an adjacency list or dictionary structure.
        Represent the start, goal  in variables.
        Represent Heuristics in a Dictonary
2. Maintain a priority queue (called pq) to decide which node to visit next.
3. Store items in the pq as a tuple: (f_score, cost_so_far, node, current_path_list).
4. Add the start node to pq with its initial f_score (the heuristic), a cost of 0, and a path list [start].
5. Create a visited set to avoid processing the same node multiple times.
6. Loop as long as the pq is not empty:
   6.1. Pop the item with the lowest f_score from pq. This gives the current f, g (cost), node, and path.
   6.2. If the node is the goal:
        6.2.1. Print the path and the g (cost).
        6.2.2. Return (the search is complete).
   6.3. If the node has not been visited yet:
        6.3.1. Add the node to the visited set.
        6.3.2. For each neighbor (and its cost) of the current node:
               6.3.2.1. Calculate the new cost to reach that neighbor: new_g = g + cost.
               6.3.2.2. Calculate the neighbor's f_score: new_f = new_g + heuristic[neighbor].
               6.3.2.3. Create the new path by appending the neighbor: new_path = path + [neighbor].
               6.3.2.4. Push the new tuple (new_f, new_g, neighbor, new_path) onto the pq.
7. Stop.
```


"""

import heapq

# --- A* Function ---
def a_star(start, goal):
    # pq stores: (f_score, g_score, node, path_list)
    pq = [(heuristic[start], 0, start, [start])]
    visited = set()

    while pq:
        # Get the item with the lowest f_score
        f, g, node, path = heapq.heappop(pq)

        # If this is the goal, we are done
        if node == goal:
            print("Path:", path, "Cost:", g)
            return

        # If we haven't visited this node, expand it
        if node not in visited:
            visited.add(node)

            # Add all neighbors to the priority queue
            for neighbor, cost in graph[node]:
                new_g = g + cost
                new_f = new_g + heuristic[neighbor]
                # We create a new path list for each neighbor
                heapq.heappush(pq, (new_f, new_g, neighbor, path + [neighbor]))
# --- Input Data ---
graph = {
    'A': [('B', 1), ('C', 3)],
    'B': [('D', 3), ('E', 1)],
    'C': [('F', 5)],
    'D': [],
    'E': [('F', 2)],
    'F': []
}
heuristic = {'A': 7, 'B': 6, 'C': 2, 'D': 6, 'E': 1, 'F': 0}

# --- Run the program ---
a_star('A', 'F')

"""**A*** With Input Handling (Recommented)



```
1. Start.
2. Build a graph (adjacency list) from the list of edges.
3. Create an empty 'visited' set.
4. Create an empty priority queue (priority_queue).
5. Push the initial item onto the priority_queue: (heuristics[start_node], 0, start_node, [start_node]). This tuple represents (f_score, g_score, node, path).
6. Loop as long as the priority_queue is not empty:
   6.1. Pop the item with the lowest f_score from priority_queue. This gives f_score, g_score, current_node, and current_path.
   6.2. If current_node is already in the 'visited' set, continue (skip this iteration).
   6.3. Add current_node to the 'visited' set.
   6.4. If current_node is the goal_node:
        6.4.1. Print the final current_path and g_score (cost).
        6.4.2. Return (the search is complete).
   6.5. For each neighbor (and its step_cost) of the current_node:
        6.5.1. If neighbor is not in the 'visited' set:
               6.5.1.1. Calculate the new cost to reach that neighbor: new_g_score = g_score + step_cost.
               6.5.1.2. Get the neighbor's heuristic: h_score = heuristics[neighbor].
               6.5.1.3. Calculate the neighbor's f_score: new_f_score = new_g_score + h_score.
               6.5.1.4. Create the new path by appending the neighbor: new_path = current_path + [neighbor].
               6.5.1.5. Push the new tuple (new_f_score, new_g_score, neighbor, new_path) onto the priority_queue.
7. If the loop finishes (queue is empty) and the goal was not found, print "No path exists".
8. Stop.
```

```
--- Code Differences: UCS vs. A* ---

1. Function Definition:
   UCS: def UCS(edges, start_node, goal_node):
   A*:  def a_star_search(edges, heuristics, start_node, goal_node):
   (A* needs the 'heuristics' dictionary).

2. Priority Queue Initialization:
   UCS:
       Pushes (g_score, node, path)
       #g_score is the cost from the start.
       heapq.heappush(priority_queue, (0, start_node, [start_node]))

   A*:
       Pushes (f_score, g_score, node, path)
       g_score = 0 (cost from start)
       f_score = g_score + h_score
       initial_f_score = heuristics[start_node]
       heapq.heappush(priority_queue, (initial_f_score, 0, start_node, [start_node]))

3. Popping from the Queue:
   UCS:
       Pops g_score, node, path
       current_cost, current_node, current_path = heapq.heappop(priority_queue)

   A*:
       Pops f_score, g_score, node, path
       f_score, g_score, current_node, current_path = heapq.heappop(priority_queue)

4. Goal Check:
   UCS:
       The cost is the first item popped (current_cost)
       print(f"Path found, The final Cost: {current_cost}")

   A*:
       The cost is the *second* item popped (g_score),
       as f_score includes the heuristic.
       print(f"Path found, The final Cost: {g_score}")

5. Neighbor Processing Loop:
   UCS:
       for neighbor, step_cost in graph[current_node]:
           if neighbor not in visited:
               new_cost = current_cost + step_cost
               new_path = current_path + [neighbor]
               Pushes (g_score, node, path)
               heapq.heappush(priority_queue, (new_cost, neighbor, new_path))

   A*:
       for neighbor, step_cost in graph[current_node]:
           if neighbor not in visited:
               #Calculate new g_score
               new_g_score = g_score + step_cost
               
               #Get heuristic for the neighbor
               h_score = heuristics[neighbor]
               
               #Calculate new f_score
               new_f_score = new_g_score + h_score
               
               new_path = current_path + [neighbor]
               
               Pushes (f_score, g_score, node, path)
               heapq.heappush(priority_queue, (new_f_score, new_g_score, neighbor, new_path))

6. Main Function Call:
   UCS:
       UCS(edges, start_node, goal_node)

   A*:
       #Must also pass the heuristics
       a_star_search(edges, heuristics, start_node, goal_node)
```
"""

import heapq

def a_star_search(edges, heuristics, start_node, goal_node):
    # Step 2: Build a graph (adjacency list) from the list of edges.
    graph = {}
    for from_node, to_node, cost in edges:
        if from_node not in graph:
            graph[from_node] = []
        if to_node not in graph:
            graph[to_node] = []
    for from_node, to_node, cost in edges:
        graph[from_node].append((to_node, cost))  # Add edge with cost

    # Step 3: Create an empty 'visited' set.
    visited = set()

    # Step 4: Create an empty priority queue (pq).
    priority_queue = []

    # Step 5: Push the initial item onto the pq.
    # Tuple is (f_score, g_score, node, path)
    # f_score = g_score (0) + heuristic[start_node]
    initial_f_score = heuristics[start_node]
    heapq.heappush(priority_queue, (initial_f_score, 0, start_node, [start_node]))

    # Step 6: Loop as long as the pq is not empty:
    while priority_queue:

        # Step 6.1: Pop the item with the lowest f_score from pq.
        f_score, g_score, current_node, current_path = heapq.heappop(priority_queue)

        # Step 6.2: If node is already in the 'visited' set, continue.
        if current_node in visited:
            continue

        # Step 6.3: Add node to the 'visited' set.
        visited.add(current_node)

        # Step 6.4: If node is the goal:
        if current_node == goal_node:
            # 6.4.1. Print the final path and g (cost).
            print(f"Path found, The final Cost: {g_score}")
            print(" ".join(map(str, current_path)))
            # 6.4.2. Return (the search is complete).
            return

        # Step 6.5: For each neighbor (and its cost) of the current node:
        for neighbor, step_cost in graph[current_node]

            # Step 6.5.1: If neighbor is not in the 'visited' set:
            if neighbor not in visited:

                # 6.5.1.1. Calculate new g_score: new_g = g + cost.
                new_g_score = g_score + step_cost

                # 6.5.1.2. Get neighbor's heuristic: h = heuristic[neighbor].
                h_score = heuristics[neighbor]

                # 6.5.1.3. Calculate neighbor's f_score: new_f = new_g + h.
                new_f_score = new_g_score + h_score

                # 6.5.1.4. Create the new path.
                new_path = current_path + [neighbor]

                # 6.5.1.5. Push the new tuple onto the pq.
                heapq.heappush(priority_queue, (new_f_score, new_g_score, neighbor, new_path))

    # Step 7: If the loop finishes, no path was found.
    print("No path exists")
    # Step 8: Stop.

# --- Input handling ---
num_nodes = int(input('Enter the number of nodes: '))
heuristics = {}
print("Enter the name and Heuristics of each node (Space Separated):")
for _ in range(num_nodes):
    node_name, h_value_str = input().split()
    h_value = int(h_value_str)
    heuristics[node_name] = h_value  # Store heuristic in a dictionary

num_edges = int(input('Enter the number of edges: '))
edges = []
print("Enter From To Cost for each edge (Space Separated): ")
for _ in range(num_edges):
    from_node, to_node, cost_str = input().split()
    cost = int(cost_str)
    edges.append((from_node, to_node, cost))  # Store edges as (from, to, cost)

start_node = input("Enter the starting node: ")
goal_node = input("Enter the goal node: ")

# Call the A* function
a_star_search(edges, heuristics, start_node, goal_node)

"""**Travelling Salesman Problem**



```
1. Represent the cities as a graph using a distance matrix (or dictionary) to store the cost between each pair of cities.
2. Define a starting city.
3. Generate all possible permutations (all possible orderings) of the *other* cities.
4. For each permutation:
   4.1. Create a complete tour (path) by adding the start city to the beginning and end of the permutation.
   4.2. Calculate the total cost of this tour by summing the distances between each adjacent city in the path.
   4.3. Check if this tour's cost is the lowest one found so far.
5. After checking all permutations, return the path and cost of the minimum-cost tour found.
6. Stop.
```


"""

from itertools import permutations

# --- Input Data ---
# Distance matrix represented as a dictionary
dist = {
    ('A','B'): 10, ('A','C'): 15, ('A','D'): 20,
    ('B','A'): 10, ('B','C'): 35, ('B','D'): 25,
    ('C','A'): 15, ('C','B'): 35, ('C','D'): 30,
    ('D','A'): 20, ('D','B'): 25, ('D','C'): 30
}

cities = ['A', 'B', 'C', 'D'] #(For Input Handling)variable 'nodes', cities = nodes
start = 'A' #(for Input Handling) Read A start city from user, start = input()

# --- Brute Force Logic ---
min_cost = float('inf')
best_path = []

# Generate permutations for all cities *except* the start city
other_cities = [c for c in cities if c != start]

for perm in permutations(other_cities):
    # Create the full path: Start -> Permutation -> Start
    path = [start] + list(perm) + [start]
    cost = 0

    # Calculate the cost for this specific path
    for i in range(len(path) - 1):
        cost += dist[(path[i], path[i+1])]

    # Update if this is the new best path
    if cost < min_cost:
        min_cost = cost
        best_path = path

# --- Print the result ---
print("Best Path:", best_path)
print("Minimum Cost:", min_cost)

"""**TSP** With Input Handling (Recomended)


```
1. Represent the cities and edges by reading a list of city names and a list of directional edges (From, To, Cost) into a distance dictionary.
2. Define a starting city.
3. Initialize MinCost to infinity and BestPath to []. Generate all possible permutations (all possible orderings) of the *other* cities.
4. For each permutation:
   4.1. Create a complete tour (path) by adding the start city to the beginning and end of the permutation.
   4.2. Initialize CurrentCost = 0 and set a flag IsPossible = True.
   4.3. Loop through each segment of the tour (e.g., from CityA to CityB):
       4.3.1. Check if the segment (CityA, CityB) exists in the distance dictionary.
       4.3.2. If it does not exist: Set IsPossible = False and break (stop checking this path).
       4.3.3. If it does exist: Add its cost to CurrentCost.
   4.4. After the loop, check if IsPossible is True AND if CurrentCost < MinCost.
   4.5. If both are true, set MinCost = CurrentCost and BestPath = CurrentPath.
5. After checking all permutations, check the final value of MinCost.
6. If MinCost is still infinity, print a message that no complete tour was found. Otherwise, print the BestPath and MinCost. Stop.
```


"""

from itertools import permutations

# --- 1. Simplified Input Handler ---

# Get city names and infer the number of nodes
cities_input = input('Enter all city names (space-separated): ')
cities = cities_input.split()

num_edges = int(input('Enter the number of edges: '))
print("Enter From To Cost for each edge (Space Separated): ")

# --- 2. Convert Edge List to 'dist' Dictionary ---
dist = {}
for _ in range(num_edges):
    from_node, to_node, cost_str = input().split()
    cost = int(cost_str)
    dist[(from_node, to_node)] = cost # Build the dictionary directly

# --- 3. Get Start City ---
start = input(f"\nEnter the starting city: ")

print("\n--- Calculating Shortest Path (Brute Force) ---")

min_cost = float('inf')
best_path = []

# Generate permutations for all cities *except* the start city
other_cities = [c for c in cities if c != start]

for perm in permutations(other_cities):
    # Create the full path: Start -> Permutation -> Start
    path = [start] + list(perm) + [start]
    cost = 0

    # Calculate the cost for this specific path
    for i in range(len(path) - 1):
      segment = (path[i], path[i+1])
      if segment not in dist:
            cost = float('inf')
            break
      cost += dist[segment]
    # Update if this is the new best path
    if cost < min_cost:
        min_cost = cost
        best_path = path

# --- 5. Print the result ---
if min_cost == float('inf'):
    print(f"No complete tour was possible from '{start}' with the given edges.")
else:
  print("Best Path:", " -> ".join(best_path))
  print("Minimum Cost:", min_cost)

"""**Map Coloring Problem**

```
1. Initialize
   a. Let assignment be a dictionary storing the color of each node (initially 0 = uncolored).
   b. Let nodes be the list of vertices in the graph.
2. Define a Recursive Function graph_coloring(index)
   a. If index == len(nodes) (all vertices are colored), return True.
   b. Else, select the current vertex: node = nodes[index].
3. Try All Colors (1 to m)
   a. For each color c from 1 to m:
      a. Check if c is safe for this node using is_safe() (The is_safe function checks if any adjacent vertices already have color c).
      b. If it is safe:
         i. Assign assignment[node] = c.
         ii. Recursively call graph_coloring(index + 1).
         iii. If the recursive call returns True, a solution is found, so return True.
         iv. Otherwise, backtrack: reset assignment[node] = 0.
4. Return False
   a. If the loop finishes and no color works for the current node, return False.
5. Define Driver Function solve_map_coloring(graph, m)
   a. Start the recursion with graph_coloring(0).
   b. If it returns True, print the final color assignment.
   c. If it returns False, print "No solution exists with m colors".
```


"""

# M-Coloring Problem on a dictionary-based graph

def is_safe(node, color, assignment, graph):
    """
    Check if it's safe to color a node with a given color.
    This function handles graphs where edges might only be listed one-way.
    """
    # Check neighbors listed in graph[node]
    for neighbor in graph[node]:
        if neighbor in assignment and assignment[neighbor] == color:
            return False

    # Check nodes that might point *to* this node (for undirected cases)
    for other in graph:
        if node in graph[other] and assignment.get(other) == color:
            return False

    return True

def graph_coloring(nodes, graph, m, assignment, index=0):
    """
    Recursive backtracking function to solve coloring.
    """
    # Base case: All nodes have been processed
    if index == len(nodes):
        return True

    node = nodes[index]

    # Try assigning each color from 1 to m
    for color in range(1, m + 1):
        if is_safe(node, color, assignment, graph):
            # Assign the color
            assignment[node] = color

            # Recurse for the next node
            if graph_coloring(nodes, graph, m, assignment, index + 1):
                return True

            # Backtrack if the recursive call failed
            assignment[node] = 0

    return False

def solve_map_coloring(graph, m):
    """
    Main driver function to set up and solve the problem.
    """
    nodes = list(graph.keys())
    assignment = {node: 0 for node in nodes} # 0 = uncolored

    if not graph_coloring(nodes, graph, m, assignment):
        print(f"No solution exists with {m} colors.")
        return None

    print("Solution exists: Coloring of vertices is")
    for node in nodes:
        print(f"Vertex {node} --> Color {assignment[node]}")
    return assignment

# -------------------
# Example
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

m = int(input("Number of colors: "))
solve_map_coloring(graph, m)

"""# **Python Programs**

**Fibonaci Series**



```
1. Input: Get the number of terms (n) to generate.
2. Initialize: Set the first two numbers:
   a = 0
   b = 1
3. Print "Fibonacci Series: ".
4. Loop: Repeat n times:
   - Print the current value of a.
   - Calculate the next term: The new 'a' will be the current 'b', and the new 'b' will be the sum of the current 'a' and 'b'.
5. End: The loop finishes after printing n terms.
```
"""

n = int(input("Enter number of terms: "))
a, b = 0, 1
print("Fibonacci Series:", end=" ")
for _ in range(n):
    print(a, end=" ")
    a, b = b, a + b
print()

"""**Armstrong Number**



```
1. Input: Get an integer from the user (store it in 'num').
2. Initialize Sum: Create a variable 'sum' and set it to 0.
3. Copy Number: Create a temporary variable 'temp' and set it equal to 'num'.
4. Start Loop: Start a loop that continues as long as 'temp' is greater than 0.
5. Extract Digit: Inside the loop, get the last digit of 'temp' (using temp % 10) and store it in 'digit'.
6. Calculate Cube: Calculate the cube of the 'digit' (digit ** 3).
7. Add to Sum: Add this cubed value to the 'sum'.
8. Remove Digit: Remove the last digit from 'temp' (using integer division, temp //= 10).
9. End Loop: The loop repeats from step 5 until 'temp' becomes 0.
10. Compare: After the loop, compare the original 'num' with the final 'sum'.
11. Output:
    - If 'num' is equal to 'sum', print that it is an Armstrong number.
    - Otherwise, print that it is not an Armstrong number.
```


"""

num = int(input("Enter a number: "))
sum = 0
temp = num
while temp > 0:
   digit = temp % 10
   sum += digit ** 3
   temp //= 10

if num == sum:
   print(f"{num} is an Armstrong number")
else:
   print(f"{num} is not an Armstrong number")

"""**Sum Of Digits** (Similar to Armstrong)



```
1. Input: Get an integer from the user (store it in 'num').
2. Initialize Sum: Create a variable 'sum' and set it to 0.
3. Copy Number: Create a temporary variable 'temp' and set it equal to 'num' (to preserve the original number).
4. Start Loop: Start a loop that continues as long as 'temp' is greater than 0.
5. Extract Digit: Inside the loop, get the last digit of 'temp' (using temp % 10).
6. Add to Sum: Add this digit to the 'sum' (using sum += ...).
7. Remove Digit: Remove the last digit from 'temp' (using integer division, temp //= 10).
8. End Loop: The loop repeats from step 5 until 'temp' becomes 0.
9. Output: After the loop, print the final 'sum' along with the original 'num'.
```


"""

num = int(input("Enter a number: "))
sum = 0
temp = num
while temp > 0:
   sum += temp % 10
   temp //= 10
print(f"Sum of digits of {num} is {sum}")

"""Palindrome (String)


```
1. Input: Get the input from the user (store it in 'original_string').
2. Reverse: Create a new string 'reversed_string' by reversing the 'original_string' (e.g., using slicing [::-1]).
3. Compare: Check if 'original_string' is exactly equal to 'reversed_string'.
4. Output:
    - If they are equal, print that it is a palindrome.
    - Otherwise, print that it is not a palindrome.
```


"""

# Get the input as a string
num_str = input("Enter a String: ")

# Reverse the string using slicing
reversed_str = num_str[::-1]

# Compare the original string with the reversed one
if num_str == reversed_str:
    print(f"{num_str} is a palindrome")
else:
    print(f"{num_str} is not a palindrome")

"""**Palindrome (Number)** (Similar to armstrong) [Do it when explicitly asked for a number else above one works fine]



```
Algorithm for Palindrome Number Check

1. Input: Get an integer from the user (store it in 'num').
2. Initialize Reverse: Create a variable 'reverse_num' and set it to 0.
3. Copy Number: Create a temporary variable 'temp' and set it equal to 'num'.
4. Start Loop: Start a loop that continues as long as 'temp' is greater than 0.
5. Extract Digit: Inside the loop, get the last digit of 'temp' (using temp % 10).
6. Build Reverse: Multiply 'reverse_num' by 10 and add the extracted 'digit' to it. (reverse_num = (reverse_num * 10) + digit).
7. Remove Digit: Remove the last digit from 'temp' (using integer division, temp //= 10).
8. End Loop: The loop repeats from step 5 until 'temp' becomes 0.
9. Compare: After the loop, compare the original 'num' with the final 'reverse_num'.
10. Output:
    - If 'num' is equal to 'reverse_num', print that it is a palindrome.
    - Otherwise, print that it is not a palindrome.
```


"""

num = int(input("Enter a number: "))
temp = num
reverse_num = 0

while temp > 0:
    digit = temp % 10
    reverse_num = (reverse_num * 10) + digit
    temp //= 10

if num == reverse_num:
    print(f"{num} is a palindrome")
else:
    print(f"{num} is not a palindrome")

"""**Factorial Of a Number**


```
1. Input: Get an integer from the user (store it in 'num').
2. Initialize Factorial: Create a variable 'factorial' and set it to 1.
3. Check for Negative:
   - If 'num' is less than 0, print an error message (e.g., "Factorial does not exist for negative numbers").
4. Calculate Factorial (if 0 or positive):
   - If 'num' is 0 or greater:
   - Start a loop that counts from 1 up to 'num' (inclusive). (If 'num' is 0, this loop will not run).
   - Inside the loop, multiply 'factorial' by the current loop number (factorial = factorial * i).
   - After the loop finishes, print the final 'factorial' value.
```


"""

num = int(input("Enter a number: "))
factorial = 1

# Check for negative numbers
if num < 0:
   print("factorial does not exist for negative numbers")
else:
   for i in range(1, num + 1):
       factorial = factorial * i
   print(f"The factorial of {num} is {factorial}")

"""**Union and Intersection of two lists**



```
1. Input: Define two lists, 'list1' and 'list2'.
2. Convert to Sets: Convert 'list1' to 'set1' and 'list2' to 'set2'. Sets automatically handle duplicates.
3. Calculate Intersection:
   - Find the elements present in BOTH 'set1' AND 'set2'.
   - Store this result (e.g., in 'intersection_list').
4. Calculate Union:
   - Find all unique elements from 'set1' OR 'set2'.
   - Store this result (e.g., in 'union_list').
5. Output: Print the original lists, the intersection list, and the union list.
```


"""

# 1. Input: Define two lists
list1 = input("Enter the first list (space-separated): ").split()
list2 = input("Enter the second list (space-separated): ").split()


print(f"List 1: {list1}")
print(f"List 2: {list2}")

# 2. Convert to Sets
set1 = set(list1)
set2 = set(list2)

# 3. Calculate Intersection (using the '&' operator)
intersection_list = list(set1 & set2)

# 4. Calculate Union (using the '|' operator)
union_list = list(set1 | set2)

# 5. Output
print(f"Intersection: {intersection_list}")
print(f"Union: {union_list}")

"""**Most Frequent word in a file**


```
1. Input: Get the file name from the user (e.g., 'sample.txt').
2. Initialize: Create an empty dictionary called 'word_count'.
3. Read File:
   - Open the specified file in read mode.
   - Read the entire content.
   - Convert the entire content to lowercase.
   - Split the content into a 'text' list of words.
4. Count Words:
   - Loop through each 'word' in the 'text' list.
   - For each 'word', increment its count in the 'word_count' dictionary. (If the word is not in the dictionary, .get(word, 0) will return 0, and the count will be set to 1).
5. Find Max:
   - After the loop, find the key (word) in 'word_count' that has the maximum value (count). Store this word in 'most_freq'.
6. Output: Print the 'most_freq' word and its count (which is found using word_count[most_freq]).
```


"""

#File Writing (Optional )
#creating sample.txt for Checking Most Frequent word in a file
# This script creates a text file named 'sample.txt' with predefined content.

# The content to be written to the file.
file_content = """hello world this is a test file
the world is a beautiful place
and hello again to this wonderful world
test test test
world hello test"""

# Open the file in write mode ('w') and write the content.
# If the file doesn't exist, it will be created. If it exists, it will be overwritten.
with open('sample.txt', 'w') as f:
    f.write(file_content)

print("File 'sample.txt' has been created successfully in your Colab environment.")

filename = input("Enter file name : ")
#try-except block optional
try:
    with open(filename, 'r') as f:
        # Read, convert to lowercase, and split all at once
        text = f.read().lower().split()

    word_count = {}

    # Count each word
    for word in text:
        word_count[word] = word_count.get(word, 0) + 1

    # Find the most frequent word
    if word_count: # Check if the dictionary is not empty
        most_freq = max(word_count, key=word_count.get)
        print(f"Most frequent word: '{most_freq}' appearing {word_count[most_freq]} times")
    else:
        print(f"The file '{filename}' is empty or contains no words.")

except FileNotFoundError:
    print(f"Error: The file '{filename}' was not found.")

"""**Count the occurance of each word in a sentance**


```
1. Input: Get a sentence (string) from the user.
2. Process Input:
   - Convert the entire sentence to lowercase.
   - Split the lowercase sentence into a list of words.
3. Initialize: Create an empty dictionary called 'count' to store word frequencies.
4. Loop: Iterate through each 'word' in the list of words.
5. Count: Inside the loop, increment the count for that 'word' in the 'count' dictionary.
   (Use `count.get(word, 0) + 1` to get the current count (or 0 if it's a new word) and add 1).
6. Output: After the loop finishes, print the final 'count' dictionary.
```


"""

sentence = input("Enter a sentence: ").lower().split()
count = {}

for word in sentence:
    count[word] = count.get(word, 0) + 1

print("Word occurrences:", count)

"""**Prime or Not**



```
1. Input: Get an integer from the user (store it in 'num').
2. Check Edge Case (<= 1):
   - If 'num' is less than or equal to 1, it is not prime. Print the result and stop.
3. Handle Main Case (> 1):
   - If 'num' is greater than 1:
   - Start a loop that counts 'i' from 2 up to 'num - 1'.
   - Inside the loop, check if 'num' is divisible by 'i' (num % i == 0).
   - If it is divisible:
     - Print that 'num' is not a prime number.
     - 'break' (exit) the loop immediately.
   - (Python 'else' for a loop): If the loop finishes completely without finding any divisors (without 'break'-ing):
     - Print that 'num' is a prime number.
```


"""

num = int(input("Enter a number: "))

# Prime numbers must be greater than 1
if num <= 1:
   print(f"{num} is not a prime number")
else:
   # Start loop to check for divisors
   for i in range(2, num):
       if (num % i) == 0:
           # Found a divisor
           print(f"{num} is not a prime number")
           break
   else:
       # Loop finished without finding any divisors
       print(f"{num} is a prime number")

"""**Extra Programs** (Optional)"""

# Matrix Multiplication
R1 = int(input("Enter the number of rows for the first matrix: "))
C1 = int(input("Enter the number of columns for the first matrix: "))

R2 = int(input("Enter the number of rows for the second matrix: "))
C2 = int(input("Enter the number of columns for the second matrix: "))

if C1 != R2:
    print("Matrix multiplication is not possible. Column of first matrix must be same as row of second matrix.")
else:
    print("Enter elements for the first matrix:")
    matrix1 = []
    for i in range(R1):
        row = list(map(int, input().split()))
        matrix1.append(row)

    print("Enter elements for the second matrix:")
    matrix2 = []
    for i in range(R2):
        row = list(map(int, input().split()))
        matrix2.append(row)

    result = [[0 for _ in range(C2)] for _ in range(R1)]

    for i in range(R1):
        for j in range(C2):
            for k in range(C1):
                result[i][j] += matrix1[i][k] * matrix2[k][j]

    print("\nResult of Matrix Multiplication:")
    for row in result:
        print(" ".join(map(str, row)))

# Matrix Transpose

# Get matrix dimensions
R = int(input("Enter the number of rows: "))
C = int(input("Enter the number of columns: "))

# Get matrix elements
print("Enter elements for the matrix (row by row):")
matrix = []
for i in range(R):
    row = list(map(int, input().split()))
    matrix.append(row)

# Create an empty result matrix with swapped dimensions (C rows, R columns)
transpose = [[0 for _ in range(R)] for _ in range(C)]

# Perform the transpose
# Iterate through the original matrix
for i in range(R):
    for j in range(C):
        # Assign the element to the swapped position in the new matrix
        transpose[j][i] = matrix[i][j]

# Print the transposed matrix
print("\nTransposed Matrix:")
for row in transpose:
    print(" ".join(map(str, row)))